namespace modifies Array {
	function backtraceToHTML( array a ) {
		boolean doneFirst = false;
		return a.join('') using ( item ) {
			string prefix = '', postfix = '<br />';
			string path = Directory.name(item['file']);
			string file = File.name(item['file']);
			string link = "$path<b><a style=\"text-decoration:none\" " +
									 " href=\"txmt://open?url=file://${item['file']}&line=${item['line']}\">$file:${item['line']}</a></b>";
			if( not path ) {
				link = "${item['file']}:${item['line']}";
			} else {
				monitor {
					if( not doneFirst ) {
						array lines = File.open(item['file']).toString().lines();
						string block = '';
						number killPrefix = 0;
						number linesBefore = 1;
						number linesAfter = 1;
						string variables;
					
						prefix = "";
						postfix = ":";
						for( number i = item['line'] - linesBefore - 1; i < (item['line'] + linesAfter) and i < lines.size(); i++ ) {
							string line = Regexp.replaceAll("\t", lines[i], "    ");
							if( (i + linesBefore + 1) == item['line'] ) {
								while( line[killPrefix] == " " )
									killPrefix++;
							}
							if( line.length() > killPrefix )
								line = "\t" + line[killPrefix..];
							else
								line = "\t" + line.preTrim(" ");
							if( (i + 1) == item['line'] )
								line = "<b style=\"color:#cff; background-color:#688\">$line</b>";
							block += "${(i + 1)}: " + line + "<br >";
						}
						postfix += "<br /><br />Code:<br /><pre style=\"background-color:#acc; margin-left: 20px;\">$block</pre>";
						if( item.keyExists('variables') ) {
							array variable_list = [];
							item['variables'].map() using ( name, value ) {
								string real_name = name[name.index(':') + 1..];
								if( real_name[0] != '!' )
									variable_list[real_name] = "<b>$real_name:</b> " + EscapeHTML((value isa string ? "'$value'" : "$value"));
							};
							if( variable_list ) {
								postfix += "Variables:<br /><div style=\"background-color:#cac; margin-left: 20px; margin-top: 20px; margin-bottom: 20px;\"><tt>" +
												variable_list.keys().sort().join(' &middot; ') using ( key ) { return variable_list[key]; } + 
											"</tt></div>";
							}
						}
					}
				} handle {
					postfix = "<br />Unable to read ${item['file']}<br />";
				}
			}
			doneFirst = true;
			return "$prefix$link in " + (item['static'] ? '<i>static</i> ' : '') + "function <b>" + item['container'] + '.' + item['function'] + "</b>$postfix";
		};
	}
	function append( array a, array b ) {
		b.each() using ( item ) {
			a[] = item;
		};
		return a;
	}
}
/**
 * @class Application
 * @brief This is the parent application class that manages page and action dispatch.
 */
class Application {
	
	/**
	 * @variable NoAction
	 * @type     string
	 * @brief    This is the internal tag when there is no action on the application request.
	 * @static
	 */
	static final string NoAction = "_______________NoAction_______________";

	/**
	 * @variable name
	 * @type     string
	 * @brief    The name of the application.
	 */
	string realName;
	string virtualName;
	array  actionHandlers;
	string action;
	/**
	 * @variable commands
	 * @type     array
	 * @brief    The commands given to the the application.
	 */
	array  commands;
	/**
	 * @variable parameters
	 * @type     array
	 * @brief    The query parameters passed to the application.
	 * @static
	 */
	array  parameters;
	object renderer;
	string error;
   
	/**
	 * @variable topLevel
	 * @type string
	 * @brief Hold the value for the top level application url with no actions or commands */
	string topLevel = '';
	/** 
	 */
	string urlPath;
	string filePath;
	
	void pushedActionData;
	
	/**
	 * @function constructor
	 * @brief The constructor of the Application class
	 * @declaration function constructor( string app )
	 * @param string app The name of the application
	 */
	function constructor( string app ) {
		log('Application.constructor', "Creating application $app");
		.realName = app;
		.registerPage('Login');
		.registerPage('ApplicationAdmin');
		.registerAction('Logout', closure( commands, parameters ) {
			Permissions.invalidateUser();
			if( commands ) {
				Application.performAction( Array.join( commands, "/" ) );
			} else {
				redirects.check('');
			}
		} );
		if( Config.Debug ) {
			.registerAction( 'WebframeworkClearCache', closure( commands, paramters ) {
				Cache.clear(commands[0]);
				Application.performAction(commands[0]);
			});
			.registerPage( 'WebframeworkQuickQuery' );
		}
		application = self;
	}
	function translationsForJavascript {
		string output = '';
		output += "// Desired language: ${I18N.desiredCatalog}\n";
		I18N.catalog.map() using ( key, translation ) {
			output += "RegisterTranslation('${.processString(key)}', '$translation');\n";
		};
		return output;
	}
	function processString( string key ) {
		key = Regexp.replaceAll("\\\\", key, "\\\\\\");
		key = Regexp.replaceAll("'", key, "\\'"); 
		return key;
	}
	/**
	 * @function registerAction
	 * @brief Register an action on the application with a given name.
	 * @description This function allows you to provide a closure that will called when an action is invoked.
	 * @declaration function registerAction( string action, object handler )
	 * @example	
	 */
	function registerAction( string action, object handler ) {
		if( action != 'MCAM' ) {
			.actionHandlers[action] = handler;
		} else {
			raise new Error("Action $name is a reserved action. Please choose another name!");
		}
	}
	function registerAction( string action ) {
		if( action != 'MCAM' ) {
			.actionHandlers[action] = recipient();
		} else {
			raise new Error("Action $name is a reserved action. Please choose another name!");
		}
	}
	/**
	 * @function registerPage
	 * @declaration function registerPage( string page )
	 * @brief This takes the name of a page resource and registers it within the system so that it can be called.
	 * @param string page Parameter Description
	 */
	array registeredPages;
	function registerPage( string page ) {
		.registeredPages[page] = true;

		.registerAction( page, closure ( commands, parameters ) {
			return GUIKit.Page.load( page, commands, parameters );
		} );
	}
	
	function invokeActualAction( void handler ) {
		if( handler isa object ) 
			return handler.invoke( .commands, .parameters );
		else if( handler isa string ) 
			return GUIKit.Page.load( handler, .commands, .parameters );
		return '';
	}
	function invokeAction( string action, array commands, array parameters ) {
		array DebugHandlers = [ 'WebframeworkClearCache' => true, 'WebframeworkQuickQuery' => true ];
		array BuiltInGlobals = [ 'TranslationStrings' => true ];
		void handler;

		if( .actionHandlers.keyExists(action) )
			handler = .actionHandlers[action];
		else if( .registeredPages.keyExists(action) ) 
			handler = action;
			
		.action = action;
		.commands = commands;
		.parameters = parameters;
		.pushedActionData = Session.valueForAction(action);
		
		if( handler ) {
			object user;
			
			metrics.checkpoint("invokeAction:$action: fetching user object");
			user = Permissions.fetchUserObject();
			metrics.checkpoint("invokeAction: setting cookies");
			if( user ) {
				Permissions.setValidationCookies(user);
			}
			if( BuiltInGlobals.keyExists(action) or 
				(DebugHandlers.keyExists(action) and Config.Debug) or
				Permissions.userAllowedForResource( user, action ) ) {
				metrics.checkpoint("invokeAction:$action: running handler invoke");
				return .invokeActualAction(handler);
			}
			else if( user != null ) {
				return .defaultErrorHandler(I('{0:username}, you do not have permission to access the resource {1:resource}. Please try logging in: {2:login link}').expand(
					HTML.bold(Permissions.fetchUserObject().toName()), HTML.bold(action),
					"<a href=\"" + uriForApplicationAction("Login/-/$action/" + Array.join( commands, "/" )) + "\">" + I('Login') + "</a>"
				));
			}
			return '';
		}
		return .defaultErrorHandler( I('Unable to invoke handler for action: {0:action}').expand(action) );
	}

	/**
	 * @function defaultErrorHandler
	 * @declaration function defaultErrorHandler( string error )
	 * @param string error The error message to be displayed
	 * @return The error page with the message added as a string
	 */
	function defaultErrorHandler( string error ) {
		.error = error;
		allowedToStoreSession = false; // This stops us smashing the current session if there is a background error
		return GUIKit.Page.load( 'Error', .commands, .parameters );
	}
	function failSafeErrorPage( object error, string message ) {
		return .failSafeErrorPage( error, message, true );
	}
	function failSafeErrorPage( object error, string message, boolean exit ) {
		string bt = error.backtrace().backtraceToHTML();
		string output = 
			HTML.html(
						HTML.head(HTML.title("Error $message")) +
						HTML.body(
									HTML.titleBox("Error $message",
												  "<i>${error.str}</i><p>" +
													HTML.blockquote(bt)
												 )
								 )
					 );
		print(output);
		if( exit )
			Core.exit();
	}
	static function performAction( string action ) {
		log('Application.performAction', action);
		if( Cache.display )
			Session.storeValue(GUIKit.ViewState, Cache.display.generateViewState(Cache.persistence));
		Session.shutdown();
		request.location( application.topLevel + "/" + action );
		Core.exit();
	}
	static function performActionWithData( string action, void data ) {
		log('Application.performAction', action);
		Session.pushValueToAction( action, data );
		if( Cache.display )
			Session.storeValue(GUIKit.ViewState, Cache.display.generateViewState(Cache.persistence));
		Session.shutdown();
		request.location( application.topLevel + "/" + action );
		Core.exit();
	}
	
	static function defaultValueForType( string type ) {
		switch( type ) {
			case 'number':
				return "0";
			case 'string':
				return "''";
			case 'array':
				return "[]";
			case 'object':
				return "null";
			case 'boolean':
				return "false";
		}
		return "''";
	}
	static array sessionVariables;
	directive session( string type, string name )
		.sessionVariables[name] = type;
	
	function fetchSessionData 
		;
	function storeSessionData
		;
	static constructor {
		if( .sessionVariables ) {
			string variableDecl, fetchSessionCode, storeSessionCode, newClass;
			.sessionVariables.map() using ( name, type ) {
				variableDecl += "$type $name; ";
				fetchSessionCode += ".$name = Session.value('$name',${.defaultValueForType(type)});";
				storeSessionCode += "Session.storeValue('$name',.$name);";
			};
			newClass = "class modifies ${Class.name(self)} {
				$variableDecl 
				function fetchSessionData { $fetchSessionCode }
				function storeSessionData { $storeSessionCode }
			}";
			log('application.constructor', "eval session data: $newClass");
			eval( newClass );
			log('application.constructor', "eval session data done");
		}
	}
	static function validateConfigurationPaths() {
		array problems = [];
		[ 'Config.PublicPath' => Config.PublicPath, 
		  'Config.DataDirectoryPath' => Config.DataDirectoryPath, 
		  'Config.CachePath' => Config.CachePath ].map() using ( key, path ) {
			if( not Posix.stat(path) ) {
				problems[] = I('Unable to find path "{0:file system directory}" specified by configuration value {1:a configuration value}. Please check it exists!').expand(path, key);
			}
		};
		if( problems )
			raise new Error(problems.join(',<br/>'));
	}
	function applicationLoaded {
		
	}
	static function run() {
		monitor {
			void klass = self;
			application = new klass();
			log('core', "Core Starup");
		} handle( error ) {
			print(I('Fatal error trying to run application: Please contact support and give them this message: "{0:message}"').expand(error.str));
		} else {
			monitor {
				if( Core.Startup( application ) ) {

					metrics.checkpoint("Going for configuration startup");
					// Load the LocalConfiguration file if we have it
					monitor {
						include( application.filePath + "Support/LocalConfiguration.feh" );
						metrics.checkpoint("Including Location Configuration");
					} handle {
						metrics.checkpoint("No Local Configuration File");
					}
			
					GUIKit.loadComponent('Component');
					/* Load the application */
	 				if( application ){
						string output;
						string action = application.action;

						metrics.checkpoint("Loading Configuration");
						Config.loadConfiguration();

						application.applicationLoaded();
				
						/* Check to see if we have any redirects required */
						redirects.check( action );

						/* Run the application command */
						metrics.checkpoint("Running Application Action");
						monitor {
							/* FIX ME */
							.validateConfigurationPaths();

							metrics.checkpoint("Running handler for ${application.action}");
							application.fetchSessionData();
							output = ( "" + application.invokeAction( application.action, application.commands, application.parameters ) );
							metrics.messages = [];
							metrics.checkpoint("Done running handler for ${application.action}");
							application.storeSessionData();
						} handle ( error ) {
							application.failSafeErrorPage(error, "Invoking '${application.action}'");
						}
						metrics.checkpoint("Outputting Information");
						print( output );
						metrics.checkpoint("Done! [${JSON.RPC.connectElapsedTime}]");
						if( Config.Debug and (not GUIKit.isBackgroundEvent) ) {
							debugOutput = [];
							metrics.checkpoints().each() using ( checkpoint ) {
								debug(__FILE__,__LINE__, checkpoint);
							};
							if( debugOutput ) {
								print(HTML.javascriptChunk(collapseDebugOutput()));
							}
						}
						Core.Shutdown();
					}
				}
			} handle( error ) {
				application.failSafeErrorPage(error, "(Critical)");
			}
		}
	}
	function quickInstallApplication( array actionList ) {
		object app, zone;
		array users, resources, zones;
		
		if( (app = webframework.Application.byName(.realName)) == null ) {
			/* Create the app */
			app = new webframework.Application();
			app.setValue('name', .realName);
			app.setValue('origin', 'webframework');
			app.setValue('useCount', 0);
		} else {
			app  = webframework.Application.load(app.id);
		}
		
		zones = app.zones;
		if( zones.size() == 0 ) {
			if( not (zone = webframework.Zone.byName('main')) ){
				zone = new webframework.Zone();
				zone.setValue('name', 'main');
			}
			app.setValue( 'zones', [ zone ] ); 
		} else {
			zone = zones[0];
		}
		
		actionList.each() using ( label ) {
			object resource = webframework.Resource.byName(label);
			if( not resource ) {
				resource = new webframework.Resource();
				resource.setValue('name', label);
				resource.setValue('type', 'page');
				zone.resourcesAdd(resource);
			}
		};
			
		[ 'guest' ].each() using ( label ) {
			object user = webframework.User.byLogin(label);
			if( not user ) {
				user = new webframework.User();
				user.setValue('username', label);
				user.setValue('active', true);
				user.setValue('timestampCreated', Date.GMTnow());
				user.setValue('timestampLastAccess', Date.GMTnow());
				zone.usersAdd(user);
			}
		};
		app.save();
	}
	
	function toHTML {
		object app = webframework.Application.completeApplication(.realName);
		if( app ) {
			array values = [];
			
			values[] = HTML.div("Application: ${app.name}");
			values[] = HTML.div("Application Origin: ${app.origin}");
			values[] = HTML.div("Application Usage Count: ${app.useCount}");
			values[] = "<p />";
			app.zones.each() using ( zone ) {
				values[] = HTML.div("Zone: ${zone.name}");
				zone.resources.each() using ( resource ) {
					values[] = HTML.div("&nbsp;&nbsp;&nbsp;Resource: ${resource.name} &raquo; ${resource.type}");
				};
				zone.users.each() using ( user ) {
					values[] = HTML.div("&nbsp;&nbsp;&nbsp;User: ${user.username} &raquo; ${user.active}");
				};
				values[] = "<p />";
			};
			return values.join("\n");
		} else {
			return HTML.div("No application ${.realName} registered with data server");
		}
	}
	function currentUserInformation {
		object currentUser = Permissions.fetchUserObject();
		string name = currentUser.toName();
		if( name == 'guest' ) {
			name = "<span style=\"color: #FCC\">$name</span>";
		} else {
			name = "<span style=\"color: #CFC\">$name</span>";
		}
		return I('User: <b>{0:user}</b>').expand(name);
	}
}
/**
 * @end
 */