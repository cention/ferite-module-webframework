
/**
 * @namespace I18N
 * @brief     Internationalisation namespace
 */
namespace I18N {
	
	string desiredCatalog;
	array  catalog;
	/**
	 * @function loadCatalog
	 * @declaration function loadCatalog( string language )
	 * @brief Load a given translation catalog out of the applications resources
	 * @param string language The language to load
	 */
	function loadCatalog( string language ) {
		.desiredCatalog = language;
		monitor {
			.catalog = include( __pathForResource("$language/translation.strings.fe","Strings") );
		} handle {
			.catalog = [];
		}
	}
	
	function cleanString( string key ) {
		key = Regexp.replaceAll("([^\\\\])?\\\\'", key, "\\1'");
		key = Regexp.replaceAll("\\\\", key, "\\\\\\");
		key = Regexp.replaceAll("'", key, "\\'");
		key = Regexp.replaceAll("[ \t\n]+", key, " ");
		return key.trim(" \r\n\t");
	}
}
/**
 * @end
 */
namespace modifies String {
	function sub( string source, string match, string replace ) {
		object o = new Regexp(match);
		return o.replace(source, replace);
	}
	function gsub( string source, string match, string replace ) {
		object o = new Regexp(match);
		return o.replaceAll(source, replace);
	}

	array UTF8map;

	function utf8ToLower( string s ) {
		string r = s.toLower();
		.UTF8map.map() using ( key, value ) {
			r = r.replace( value, key );
		};
		return r;
	}
	function utf8ToUpper( string s ) {
		string r = s.toUpper();
		.UTF8map.map() using ( key, value ) {
			r = r.replace( key, value );
		};
		return r;
	}
	function nextCharacterLength( string str) {
		number length = str.length();
		number i = 0;
		number b1 = String.charToNum(str[i]);
		if( (b1 & 0b11000000) == 0b11000000 ) {
			number b2 = ((i + 1) < length ? String.charToNum(str[i+1]) : 0);
			number b3 = ((i + 2) < length ? String.charToNum(str[i+2]) : 0);
			number b4 = ((i + 3) < length ? String.charToNum(str[i+3]) : 0);

			// We do a proper check
			// 2 byte
			if( (b1 & 0b11000000) == 0b11000000 and
				(b2 & 0b10000000) == 0b10000000 ) {
				return 2;
			}

			// 3 byte
			if( (b1 & 0b11100000) == 0b11100000 and
				(b2 & 0b10000000) == 0b10000000 and
				(b3 & 0b10000000) == 0b10000000 ) {
				return 3;
			}

			// 4 byte
			if( (b1 & 0b11110000) == 0b11110000 and
				(b2 & 0b10000000) == 0b10000000 and
				(b3 & 0b10000000) == 0b10000000 and
				(b4 & 0b10000000) == 0b10000000 ) {
				return 4;
			}
		}
		return 1;
	}
}

/**
 * @group I18N Tools
 * @brief A set of helper functions for I18N work
 */

	/**
	 * @function formatDate
	 * @declaration function formatDate( number date )
	 * @brief Format a GMT timestamp into an application local date representation as a string
	 * @param number date The timestamp
	 * @return A string representation
	 * @warning Uses the Config.DateFormat variable
	 */
	function formatDate( number date ) {
		number localDate = date + (Config.TimeZoneOffset * 60); // Ideally this will be per user at somepoint.
		return Date.date(localDate).format(Config.DateFormat);
	}
	/**
	 * @function formatDateTime
	 * @declaration function formatDateTime( number date )
	 * @brief Format a GMT timestamp into an application local date and time representation as a string
	 * @param number date The timstamp
	 * @return A string representation
	 * @warning Uses the Config.DateFormat variable
	 */
	function formatDateTime( number date ) {
		number localDate = date + (Config.TimeZoneOffset * 60); // Ideally this will be per user at somepoint.
		return Date.date(localDate).format(Config.DateFormat + ' %H:%M');
	}
	/**
	 * @function formatTime
	 * @declaration function formatTime( number date )
	 * @brief Format a GMT timestamp into an application local time representation as a string
	 * @param number date The timstamp
	 * @return A string representation in HOUR:MINUTE
	 */
	function formatTime( number date ){
		number localDate = date + (Config.TimeZoneOffset * 60); // Ideally this will be per user at somepoint.
		return Date.date(localDate).format('%H:%M');
	}
	/**
	 * @function formatPrice
	 * @declaration function formatPrice( number major, number minor )
	 * @brief Format a price to an application local string representation
	 * @param number major The whole value
	 * @param number minor The decimal value
	 * @return The price formated using the Config.PriceSeparator value
	 */
	function formatPrice( number major, number minor ) {
		return "$major${Config.PriceSeparator}$minor";
	}
	/**
	 * @function I
	 * @declaration function I( string toTranslate )
	 * @brief Take a given string, consule the currently loaded translation dictionary and return the translated string
	 * @param string toTranslate The string to translate
	 * @return The translated string, or the original string if no translation exists.
	 */
	function I( string toTranslate ) {
		string key = I18N.cleanString(toTranslate);
		if( I18N.catalog.keyExists(key) )
			return I18N.catalog[key];
		return toTranslate;
	}
/**
 * @end
 */

String.UTF8map = [ 'å' => 'Å', 'ä' => 'Ä', 'ö' => 'Ö' ];
