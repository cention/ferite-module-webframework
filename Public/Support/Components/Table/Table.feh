namespace modifies GUIKit {
	class CSimpleTableColumnItem extends GUIKit.AbstractComponent {
		function render {
			return .textValue;
		}
	}
	
	class CSimpleTableDataSource {
		object _table;
		array _rows;
		
		function constructor( object table ) {
			._table = table;
			.clear();
		}
		
		function clear
			._rows = [];
		
		function append( array _row )
			._rows[] = _row;
		
		function set( array rows )
			._rows = rows;
		
		function _create( string className ) {
			if( className != 'CSimpleTableDataSource' ) {
				void klass = Class.locate('GUIKit.' + className );
				object item = new klass();
				return item;
			}
			return null;
		}
		
		function columnHeaders {
			array columnHeaders = [];
			
			._table.contents.each() using ( id ) {
				object column = Cache.components[id];
				string textValue = column.textValue();
				string style = 'padding:4px;';
				
				if( not textValue )
					textValue = '&nbsp;';
				
				if( column.size.width ) {
					style += "width:${column.size.width};";
				} 
				columnHeaders[] = [ 'ID' => id, 'TextValue' => textValue, 'Style' => style, 'MaxLength' => column.maxLength(), 'IgnoreClicks' => column.ignoreClicks(), 'Sortable' => column.sortable() ];
			};
			
			return columnHeaders;
		}
		
		function rows {
			array rows = [];
			number _rowCount = ._rows.size();
			array _columnComponents = [];
			
			._table.contents.each() using ( id ) {
				object column = Cache.components[id];
				string className = column.itemClass();
				_columnComponents[] = ._create( className );
			};
			
			for( number i = 0; i < _rowCount; i++ ) {
				array _columns = ._rows[i];
				array rowColumns = [];

				for( number j = 0; j < _columnComponents.size(); j++ ) {
					void attributes = _columns[j];
					object component = _columnComponents[j];
					string itemRender;
					
					if( component ) {
						if( attributes isa array ) {
							component.processAttributes( attributes );
						} else {
							component.processAttributes([ 'TextValue' => attributes ]);
						}
						itemRender = component.render();
					} else {
						if( attributes isa array ) {
							itemRender = '' + attributes['TextValue'];
						} else {
							itemRender = '' + attributes;
						}
					}
					
					rowColumns[] = [ 'ItemRender' => (itemRender ? itemRender : '&nbsp;') ];
				};
				
				row['Columns'] = rowColumns;
				rows[] = row;
			};
			return rows;
		}
	}
	
	class CTableColumn extends GUIKit.AbstractComponent {
		[attribute string  itemClass 'CSimpleTableColumnItem' 'The class to use to initialise items in the column'];
		[attribute number  maxLength 0                        'Maximum character length for an attribute'];
		[attribute boolean ignoreClicks false                 'Whether cells within this column accept clicks'];
		[attribute boolean sortable true                      'Can the column be sorted'];
		[attribute string  sorted                             'Is column sorted?'];
		[attribute boolean secondarySort false                'Whether the colunn is the secondary sort column'];
		[attribute string  map ''                             'Column ID to data map'];
	}
	
	class CTable extends GUIKit.AbstractContainerComponent {
		object source;
		
		[attribute boolean sortable true 'Whether or not the table can be sorted'];
		[attribute boolean autoSort false 'Whether the table should automatically note a sort change after data update'];
		
		function addColumn( string columnName, string itemClass ) {
			object column;
			string id;
			
			if( columnName )
				id = .id + '_' + columnName;
			else
				id = .id + '_Column' + .contents.size();
			
			if( not .contents.valueExists( id ) ) {
				if( Cache.components.keyExists( id ) )
					column = Cache.components[id];
				else
					column = new GUIKit.CTableColumn( id );
			
				column.setTextValue( columnName );
				column.setItemClass( itemClass );
			
				.contents[] = id;
				return column;
			} else {
				return Cache.components[id];
			}
			return null;
		}
		
		function addColumn( string columnName ) {
			object column;
			string id;
			
			if( columnName )
				id = .id + '_' + columnName;
			else
				id = .id + '_Column' + .contents.size();
			
			if( not .contents.valueExists( id ) ) {
				if( Cache.components.keyExists(id) )
					column = Cache.components[id];
				else
					column = new GUIKit.CTableColumn( id );
			
				column.setTextValue( columnName );
			
				.contents[] = id;
				return column;
			} else {
				return Cache.components[id];
			}
			return null;
		}
		
		function _createDataSource {
			if( not .source )
				.source = new GUIKit.CSimpleTableDataSource( self );
		}
		
		function setDataSource( array source ) {
			._createDataSource();
			.source.clear();
			.source.set( source );
		}
		
		function handleChildren( array children, object renderEngine ) {
			.contents = [];
			children.each() using ( child ) {
				if( GUIKit.XMLTools.nodeIsSpecificWFComponent( child, 'CTableColumn' ) ) {
					string attribute = GUIKit.XMLTools.nodeHasAttribute( child, 'ID' );
					if( attribute ) {
						.contents[] = attribute;
						return;
					}
				}
				child.removeSelf();
			};
		}
		
		function styleSheetCursor() {
			return 'default';
		}
			
		function renderContainerStart
			return "";
		
		function renderContainerEnd {
			if( .visible() and .contents.size() > 0 ) {
				array values = .generateTemplateAttributes( 'wfTable' );
				object component = GUIKit.componentByName( 'Table' );
				string path = component.pathForComponentResource( 'Table.template' );
				if( not .source ) {
					._createDataSource();
				}
				if( .source ) {
					array columnMap = [];
					
					values['ColumnHeaders'] = .source.columnHeaders();
					values['Rows'] = .source.rows();
					
					.contents.each() using ( id ) {
						object column = Cache.components[id];
						if( column.sorted().toLower() == 'desc' or column.sorted().toLower() == 'asc' ) {
							values['InitialSort'] = column.id;
							values['InitialSortDirection'] = column.sorted().toLower();
						}
						if( column.secondarySort() ) {
							values['SecondarySort'] = column.id;
						}
						if( column.map() ) {
							columnMap[column.id] = column.map();
						}
					};
					values['Map'] = JSON.valueToJSON(columnMap);
				}
				values['DefaultStyle'] = JSON.valueToJSON([ 'fg' => '#000', 'bg' => '#FFF' ]);
				if( .autoSort() ) {
					values['AutoSort'] = true;
				}
				return GUIKit.ViewTemplate.renderPath( path, values );
			}
			return "";
		}
	}
}

